/**
 * Tiledesk Integration Service
 *
 * Service for Tiledesk external bot integration.
 * Handles bot creation, webhook registration, and management via agent-bridge.
 */

// import { getFirestore, doc, getDoc } from 'firebase/firestore'; // REMOVED: Firebase/Firestore
import { getServiceApiUrl } from '../config/apiConfig';
import { logActivity } from '../activity/activityService';
import { AGENT_ACTIVITIES, RESOURCE_TYPES } from '../../constants/activityTypes';

// FIRESTORE STUBS - These functions are stubbed because Firestore is disabled
const collection = (...args) => { console.warn('Firestore disabled: collection() called'); return null; };
const doc = (...args) => { console.warn('Firestore disabled: doc() called'); return null; };
const getDoc = async (...args) => { console.warn('Firestore disabled: getDoc() called'); return { exists: () => false, data: () => ({}) }; };
const getDocs = async (...args) => { console.warn('Firestore disabled: getDocs() called'); return { docs: [], size: 0, forEach: () => {} }; };
const query = (...args) => { console.warn('Firestore disabled: query() called'); return null; };
const where = (...args) => { console.warn('Firestore disabled: where() called'); return null; };
const orderBy = (...args) => { console.warn('Firestore disabled: orderBy() called'); return null; };
const limit = (...args) => { console.warn('Firestore disabled: limit() called'); return null; };
const onSnapshot = (...args) => { console.warn('Firestore disabled: onSnapshot() called'); const callback = args.find(a => typeof a === 'function'); if (callback) setTimeout(() => callback({ docs: [], size: 0, forEach: () => {} }), 0); return () => {}; };
const getFirestore = () => { console.warn('Firestore disabled: getFirestore() called'); return null; };


class TiledeskService {
  constructor() {
    this.baseURL = getServiceApiUrl('agent-bridge');
  }

  /**
   * Get Tiledesk bot account by agent ID - Direct Firestore query
   */
  async getBot(agentId) {
    try {
      console.log('[Tiledesk] Loading bot for agentId:', agentId);
      const db = getFirestore();

      // Query tiledesk_accounts collection by agent_id
      const docRef = doc(db, 'tiledesk_accounts', agentId);
      console.log('[Tiledesk] Firestore query path:', `tiledesk_accounts/${agentId}`);

      const docSnap = await getDoc(docRef);
      console.log('[Tiledesk] Document exists:', docSnap.exists());

      if (!docSnap.exists()) {
        console.warn('[Tiledesk] No document found for agentId:', agentId);
        return null; // Bot not found
      }

      const botData = docSnap.data();
      console.log('[Tiledesk] Raw bot data from Firestore:', botData);
      console.log('[Tiledesk] Has bot_id field:', !!botData.bot_id, 'Value:', botData.bot_id);
      console.log('[Tiledesk] Has status field:', !!botData.status, 'Value:', botData.status);

      const result = {
        id: docSnap.id,
        ...botData,
        agent_id: agentId,
        // Handle Firestore Timestamp conversion
        created_at: botData.created_at,
        updated_at: botData.updated_at
      };

      console.log('[Tiledesk] Returning result:', result);
      return result;
    } catch (error) {
      console.error('[Tiledesk] Error getting bot from Firestore:', error);
      throw error;
    }
  }

  /**
   * Generate webhook URL for agent
   * @deprecated - Webhook URL is now auto-generated by backend from deployed agent service URL
   * Keeping this method for backward compatibility, but it's no longer used
   */
  generateWebhookUrl(agentId) {
    // Get the agent service URL pattern from environment or use default
    const region = process.env.REACT_APP_GOOGLE_CLOUD_REGION || 'us-central1';
    const projectId = process.env.REACT_APP_GOOGLE_CLOUD_PROJECT || '';

    // Format: https://agent-{agent_id}.run.app/api/tiledesk/webhook
    return `https://agent-${agentId.toLowerCase()}-${projectId}.${region}.run.app/api/tiledesk/webhook`;
  }

  /**
   * Sign in to Tiledesk and get user JWT token
   * @param {string} email - Tiledesk account email
   * @param {string} password - Tiledesk account password
   * @param {string} projectId - Tiledesk project ID
   * @returns {Promise<{success: boolean, token: string, user: object}>}
   */
  async signIn(email, password, projectId) {
    try {
      const response = await fetch(`${this.baseURL}/api/tiledesk/signin`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          email,
          password,
          project_id: projectId
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        if (response.status === 401) {
          throw new Error('Invalid email or password');
        }

        const errorMessage = errorData.detail || errorData.message || `Sign in failed: ${response.status}`;
        throw new Error(errorMessage);
      }

      const result = await response.json();
      return result;
    } catch (error) {
      console.error('Error signing in to Tiledesk:', error);
      throw error;
    }
  }

  /**
   * Create Tiledesk bot for agent
   * Note: bot_url is now auto-generated by backend from deployed agent service URL
   */
  async createBot(agentId, projectId, apiToken, botName, botDescription = null) {
    try {
      const headers = {
        'Content-Type': 'application/json'
      };

      const requestBody = {
        agent_id: agentId,
        project_id: projectId,
        api_token: apiToken,
        bot_name: botName
        // bot_url is now auto-generated by backend from Firestore agent_servers collection
      };

      if (botDescription) {
        requestBody.bot_description = botDescription;
      }

      const response = await fetch(`${this.baseURL}/api/tiledesk/accounts`, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        // Handle validation errors from FastAPI (422)
        if (response.status === 422 && errorData.details?.validation_errors) {
          const validationErrors = errorData.details.validation_errors
            .map(err => `${err.loc?.join('.')} - ${err.msg}`)
            .join('; ');
          throw new Error(`Validation error: ${validationErrors}`);
        }

        // Handle other error formats
        const errorMessage = errorData.detail
          || errorData.message
          || errorData.error
          || `Bot creation failed with status ${response.status}`;
        throw new Error(errorMessage);
      }

      const result = await response.json();

      // Log Tiledesk bot creation activity
      try {
        await logActivity({
          activity_type: AGENT_ACTIVITIES.INTEGRATION_CONNECTED,
          resource_type: RESOURCE_TYPES.INTEGRATION,
          resource_id: agentId,
          related_resource_type: RESOURCE_TYPES.AGENT,
          related_resource_id: agentId,
          activity_details: {
            integration_type: 'tiledesk',
            project_id: projectId,
            bot_name: botName,
            bot_id: result.bot_id,
            webhook_url: result.bot_url // Use webhook URL from backend response
          }
        });
      } catch (logError) {
        console.error('Failed to log Tiledesk bot creation activity:', logError);
      }

      return result;
    } catch (error) {
      console.error('Error creating Tiledesk bot:', error);
      throw error;
    }
  }

  /**
   * Register or update webhook URL for bot
   */
  async registerWebhook(agentId, webhookUrl) {
    try {
      const headers = {
        'Content-Type': 'application/json'
      };

      const response = await fetch(
        `${this.baseURL}/api/tiledesk/accounts/${agentId}/webhook?webhook_url=${encodeURIComponent(webhookUrl)}`,
        {
          method: 'POST',
          headers
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.detail || `Webhook registration failed: ${response.status}`);
      }

      const result = await response.json();
      return result;
    } catch (error) {
      console.error('Error registering webhook:', error);
      throw error;
    }
  }

  /**
   * Get bot health status
   */
  async getBotHealth(agentId) {
    try {
      const response = await fetch(`${this.baseURL}/api/tiledesk/accounts/${agentId}/health`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.detail || `Health check failed: ${response.status}`);
      }

      const result = await response.json();
      return result;
    } catch (error) {
      console.error('Error getting bot health:', error);
      throw error;
    }
  }

  /**
   * Connect an existing Tiledesk bot to agent
   */
  async connectExistingBot(agentId, projectId, apiToken, botId, botName = null) {
    try {
      const headers = {
        'Content-Type': 'application/json'
      };

      const requestBody = {
        agent_id: agentId,
        project_id: projectId,
        api_token: apiToken,
        bot_id: botId
      };

      if (botName) {
        requestBody.bot_name = botName;
      }

      const response = await fetch(`${this.baseURL}/api/tiledesk/accounts/connect-existing`, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        // Handle validation errors from FastAPI (422)
        if (response.status === 422 && errorData.details?.validation_errors) {
          const validationErrors = errorData.details.validation_errors
            .map(err => `${err.loc?.join('.')} - ${err.msg}`)
            .join('; ');
          throw new Error(`Validation error: ${validationErrors}`);
        }

        // Handle other error formats
        const errorMessage = errorData.detail
          || errorData.message
          || errorData.error
          || `Connecting existing bot failed with status ${response.status}`;
        throw new Error(errorMessage);
      }

      const result = await response.json();

      // Log Tiledesk bot connection activity
      try {
        await logActivity({
          activity_type: AGENT_ACTIVITIES.INTEGRATION_CONNECTED,
          resource_type: RESOURCE_TYPES.INTEGRATION,
          resource_id: agentId,
          related_resource_type: RESOURCE_TYPES.AGENT,
          related_resource_id: agentId,
          activity_details: {
            integration_type: 'tiledesk',
            connection_method: 'existing_bot',
            project_id: projectId,
            bot_id: botId,
            webhook_url: result.webhook_url
          }
        });
      } catch (logError) {
        console.error('Failed to log Tiledesk bot connection activity:', logError);
      }

      return result;
    } catch (error) {
      console.error('Error connecting existing Tiledesk bot:', error);
      throw error;
    }
  }

  /**
   * Configure default fallback intent to route to AI agent
   *
   * @param {string} botId - Tiledesk bot ID
   * @param {string} agentId - Agent ID
   * @param {string} projectId - Tiledesk project ID
   * @param {string} apiToken - Tiledesk API token
   * @returns {Promise<Object>} Configuration result
   */
  async configureFallbackIntent(botId, agentId, projectId, apiToken) {
    try {
      console.log('[Tiledesk] Configuring fallback intent for bot:', botId);

      const headers = {
        'Content-Type': 'application/json'
      };

      const requestBody = {
        agent_id: agentId,
        project_id: projectId,
        api_token: apiToken
      };

      const response = await fetch(`${this.baseURL}/api/tiledesk/bots/${botId}/configure-fallback`, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.detail
          || errorData.message
          || `Failed to configure fallback intent (status ${response.status})`;
        throw new Error(errorMessage);
      }

      const result = await response.json();
      console.log('[Tiledesk] Fallback intent configured successfully:', result);

      // Log fallback configuration activity
      try {
        await logActivity({
          activity_type: AGENT_ACTIVITIES.CONFIGURATION_UPDATED,
          resource_type: RESOURCE_TYPES.INTEGRATION,
          resource_id: agentId,
          related_resource_type: RESOURCE_TYPES.AGENT,
          related_resource_id: agentId,
          activity_details: {
            integration_type: 'tiledesk',
            configuration_type: 'fallback_intent',
            bot_id: botId,
            fallback_configured: true,
            webhook_url: result.webhook_url
          }
        });
      } catch (logError) {
        console.error('Failed to log fallback configuration activity:', logError);
      }

      return result;
    } catch (error) {
      console.error('Error configuring fallback intent:', error);
      throw error;
    }
  }

  /**
   * List all bots in a Tiledesk project
   */
  async listBots(projectId, apiToken) {
    try {
      const response = await fetch(`${this.baseURL}/api/tiledesk/projects/${projectId}/bots`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          api_token: apiToken
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.detail || `Failed to list bots: ${response.status}`);
      }

      const result = await response.json();
      return result.bots || [];
    } catch (error) {
      console.error('Error listing Tiledesk bots:', error);
      throw error;
    }
  }

  /**
   * Delete Tiledesk bot
   */
  async deleteBot(agentId) {
    try {
      const response = await fetch(`${this.baseURL}/api/tiledesk/accounts/${agentId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.detail || `Bot deletion failed: ${response.status}`);
      }

      const result = await response.json();

      // Log Tiledesk bot deletion activity
      try {
        await logActivity({
          activity_type: AGENT_ACTIVITIES.INTEGRATION_DISCONNECTED,
          resource_type: RESOURCE_TYPES.INTEGRATION,
          resource_id: agentId,
          related_resource_type: RESOURCE_TYPES.AGENT,
          related_resource_id: agentId,
          activity_details: {
            integration_type: 'tiledesk',
            agent_id: agentId
          }
        });
      } catch (logError) {
        console.error('Failed to log Tiledesk bot deletion activity:', logError);
      }

      return result;
    } catch (error) {
      console.error('Error deleting Tiledesk bot:', error);
      throw error;
    }
  }

  /**
   * Validate Tiledesk Project ID format
   */
  validateProjectId(projectId) {
    if (!projectId) return false;

    // Tiledesk Project ID is typically a MongoDB ObjectId (24 hex characters)
    const projectIdRegex = /^[a-f0-9]{24}$/i;
    return projectIdRegex.test(projectId.trim());
  }

  /**
   * Validate API Token
   */
  validateApiToken(apiToken) {
    if (!apiToken) return false;

    // API token should be a non-empty string
    // Minimum length check (adjust based on Tiledesk's actual token format)
    return apiToken.trim().length >= 20;
  }
}

// Create singleton instance
const tiledeskService = new TiledeskService();

export default tiledeskService;
